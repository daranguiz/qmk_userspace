"""
macOS .keylayout XML file generator for row-staggered keyboards

This module generates complete .keylayout XML files that can be installed
on macOS to remap keyboard layouts at the OS level.
"""

from pathlib import Path
from typing import List, Dict, Tuple
from data_model import RowStaggerConfig
from keylayout_translator import KeylayoutTranslator


class KeylayoutGenerator:
    """Generate macOS .keylayout XML files from row-staggered YAML configs"""

    def __init__(self, translator: KeylayoutTranslator, template_path: Path):
        self.translator = translator
        self.template_path = template_path
        self._load_template()

    def _load_template(self):
        """Load and parse the base .keylayout XML template"""
        with open(self.template_path, 'r') as f:
            self.template_content = f.read()

        # Extract the actions section (diacritics - keep unchanged)
        actions_start = self.template_content.find('<actions>')
        actions_end = self.template_content.find('</actions>') + len('</actions>')
        self.actions_section = self.template_content[actions_start:actions_end]

        # Extract the terminators section (keep unchanged)
        term_start = self.template_content.find('<terminators>')
        term_end = self.template_content.find('</terminators>') + len('</terminators>')
        self.terminators_section = self.template_content[term_start:term_end]

        # Extract modifierMap section (keep unchanged)
        mod_start = self.template_content.find('<modifierMap')
        mod_end = self.template_content.find('</modifierMap>') + len('</modifierMap>')
        self.modifier_section = self.template_content[mod_start:mod_end]

        # Extract layouts section (keep unchanged)
        layouts_start = self.template_content.find('<layouts>')
        layouts_end = self.template_content.find('</layouts>') + len('</layouts>')
        self.layouts_section = self.template_content[layouts_start:layouts_end]

        # Extract JIS keyMapSet (keep unchanged)
        jis_start = self.template_content.find('<keyMapSet id="JIS">')
        jis_end = self.template_content.find('</keyMapSet>', jis_start) + len('</keyMapSet>')
        self.jis_section = self.template_content[jis_start:jis_end]

    def generate_keylayout(self, config: RowStaggerConfig) -> str:
        """
        Generate complete .keylayout XML from configuration

        Args:
            config: RowStaggerConfig with layout definition

        Returns:
            Complete XML content ready to write to .keylayout file
        """
        # Infer shift layer from base
        shift_layout = self.translator.infer_shift_layer(config.layout)

        # Generate keymaps
        base_keymap = self._generate_keymap(config.layout, index=0, layer_name="Base / Command Layer")
        shift_keymap = self._generate_keymap(shift_layout, index=1, layer_name="Shift Layer")
        caps_keymap = self._generate_caps_lock_keymap(config.layout, shift_layout, index=2)

        # Get unchanged keymaps (option, control) from template
        option_keymaps = self._extract_option_control_keymaps()

        # Build ANSIISO keyMapSet
        ansiiso_section = f'''    <keyMapSet id="ANSIISO">
{base_keymap}
{shift_keymap}
{caps_keymap}
{option_keymaps}
    </keyMapSet>'''

        # Assemble complete XML
        xml = f'''<?xml version="1.1" encoding="UTF-8"?>
<!DOCTYPE keyboard SYSTEM "file://localhost/System/Library/DTDs/KeyboardLayout.dtd">
<!-- Generated by keyboard-config build system -->
<keyboard group="{config.group}" id="{config.id}" name="{config.name}" maxout="1">
{self.layouts_section}
{self.modifier_section}
{ansiiso_section}
{self.jis_section}
{self.actions_section}
{self.terminators_section}
</keyboard>'''

        return xml

    def _generate_keymap(self, layout: List[List[str]], index: int, layer_name: str) -> str:
        """
        Generate a single <keyMap> section

        Args:
            layout: 3 rows of keys
            index: keyMap index (0=base, 1=shift, 2=caps)
            layer_name: Human-readable layer name for comment

        Returns:
            <keyMap> XML section as string
        """
        # Translate layout to (keycode, output) pairs
        mappings = self.translator.translate_keymapping(layout)

        # Create a dict for quick lookup
        keycode_to_output = {kc: out for kc, out in mappings}

        # Generate XML
        lines = [f'        <keyMap index="{index}">']
        lines.append(f'            <!-- {layer_name} -->')

        # Generate key entries for all keycodes in order
        # We need to include ALL keys (not just customized ones)
        all_keycodes = self._get_all_keycodes_template()

        for keycode, default_output, comment in all_keycodes:
            if keycode in keycode_to_output:
                # Custom key from layout
                output = keycode_to_output[keycode]
                escaped = self.translator.escape_xml(output)

                # Check if this is a letter that might need action for diacritics
                if output.isalpha() and len(output) == 1 and output.lower() in ['a', 'e', 'i', 'n', 'o', 'u', 'y']:
                    # Use action for letters that can have diacritics
                    action_id = output.lower()
                    if index == 1 or (index == 2 and output.isupper()):
                        # Shift or caps: uppercase letter
                        action_id = action_id.upper()
                    lines.append(f'            <key code="{keycode}" action="{action_id}"/>')
                else:
                    # Regular output
                    lines.append(f'            <key code="{keycode}" output="{escaped}"/>')
            else:
                # Use template default (apply shift transformation if this is shift layer)
                output = default_output
                if index == 1:  # Shift layer
                    # Apply shift transformation to the default
                    shifted = self.translator.get_output_for_key(default_output, shifted=True)
                    output = self.translator.escape_xml(shifted)
                lines.append(f'            <key code="{keycode}" output="{output}"/>')

        lines.append('        </keyMap>')
        return '\n'.join(lines)

    def _generate_caps_lock_keymap(
        self,
        base_layout: List[List[str]],
        shift_layout: List[List[str]],
        index: int
    ) -> str:
        """
        Generate caps lock keyMap (index=2)

        In caps lock mode:
        - Letters: uppercase
        - Symbols: unchanged from base

        Args:
            base_layout: Base layer
            shift_layout: Shift layer (for letter reference)
            index: keyMap index (2)

        Returns:
            <keyMap> XML section
        """
        # Create caps lock layout: uppercase letters, base symbols
        caps_layout = []
        for base_row in base_layout:
            caps_row = []
            for key in base_row:
                if key.isalpha() and len(key) == 1:
                    caps_row.append(key.upper())
                else:
                    caps_row.append(key)  # Keep symbols from base
            caps_layout.append(caps_row)

        return self._generate_keymap(caps_layout, index, "Capitals Lock Layer")

    def _extract_option_control_keymaps(self) -> str:
        """
        Extract option and control keyMaps from template (index 3-7)

        These layers stay unchanged from QWERTY default
        """
        # Find keyMap index="3" through index="7"
        result = []

        for idx in range(3, 8):
            pattern = f'<keyMap index="{idx}">'
            start = self.template_content.find(pattern)
            if start == -1:
                continue

            # Find matching </keyMap>
            end = self.template_content.find('</keyMap>', start) + len('</keyMap>')
            keymap = self.template_content[start:end]

            # Indent properly
            indented = '\n'.join(['        ' + line if line.strip() else line
                                  for line in keymap.split('\n')])
            result.append(indented)

        return '\n'.join(result)

    def _get_all_keycodes_template(self) -> List[Tuple[int, str, str]]:
        """
        Get ordered list of all keycodes with template defaults

        Returns:
            List of (keycode, default_output, comment) tuples
        """
        # Standard ANSI keyboard keycodes in order
        # Format: (keycode, default_output, comment)
        return [
            # Alpha keys (home row)
            (0, 'a', None),      # A
            (1, 's', None),      # S
            (2, 'd', None),      # D
            (3, 'f', None),      # F
            (4, 'h', None),      # H
            (5, 'g', None),      # G
            (6, 'z', None),      # Z
            (7, 'x', None),      # X
            (8, 'c', None),      # C
            (9, 'v', None),      # V
            (10, 'ยง', None),     # ISO section sign (not used on ANSI)
            (11, 'b', None),     # B
            (12, 'q', None),     # Q
            (13, 'w', None),     # W
            (14, 'e', None),     # E
            (15, 'r', None),     # R
            (16, 'y', None),     # Y
            (17, 't', None),     # T
            (18, '1', None),     # 1
            (19, '2', None),     # 2
            (20, '3', None),     # 3
            (21, '4', None),     # 4
            (22, '6', None),     # 6
            (23, '5', None),     # 5
            (24, '=', None),     # =
            (25, '9', None),     # 9
            (26, '7', None),     # 7
            (27, '-', None),     # -
            (28, '8', None),     # 8
            (29, '0', None),     # 0
            (30, ']', None),     # ]
            (31, 'o', None),     # O
            (32, 'u', None),     # U
            (33, '[', None),     # [
            (34, 'i', None),     # I
            (35, 'p', None),     # P
            (36, '&#x000D;', 'Enter'),
            (37, 'l', None),     # L
            (38, 'j', None),     # J
            (39, '&#x0027;', None),  # '
            (40, 'k', None),     # K
            (41, ';', None),     # ;
            (42, '\\', None),    # \
            (43, ',', None),     # ,
            (44, '/', None),     # /
            (45, 'n', None),     # N
            (46, 'm', None),     # M
            (47, '.', None),     # .
            (48, '&#x0009;', 'Tab'),
            (49, ' ', 'Spacebar'),
            (50, '`', None),     # `
            (51, '&#x0008;', 'Backspace'),
            (52, '&#x0003;', None),
            (53, '&#x001B;', 'Escape'),
            # Function keys and special keys (keep defaults)
            (65, '.', None),
            (66, '&#x001D;', None),
            (67, '*', None),
            (69, '+', None),
            (70, '&#x001C;', None),
            (71, '&#x001B;', None),
            (72, '&#x001F;', None),
            (75, '/', None),
            (76, '&#x0003;', None),
            (77, '&#x001E;', None),
            (78, '-', None),
            (81, '=', None),
            (82, '0', None),
            (83, '1', None),
            (84, '2', None),
            (85, '3', None),
            (86, '4', None),
            (87, '5', None),
            (88, '6', None),
            (89, '7', None),
            (91, '8', None),
            (92, '9', None),
            # Function keys
            (96, '&#x0010;', 'F5'),
            (97, '&#x0010;', 'F6'),
            (98, '&#x0010;', 'F7'),
            (99, '&#x0010;', 'F3'),
            (100, '&#x0010;', 'F8'),
            (101, '&#x0010;', 'F9'),
            (102, '&#x0010;', 'F11'),
            (103, '&#x0010;', 'F13'),
            (104, '&#x0010;', 'F16'),
            (105, '&#x0010;', 'F14'),
            (106, '&#x0010;', 'F10'),
            (107, '&#x0010;', 'F12'),
            (108, '&#x0010;', 'F15'),
            (109, '&#x0010;', 'Help'),
            (110, '&#x0010;', 'Home'),
            (111, '&#x0010;', 'Page Up'),
            (112, '&#x0010;', 'Delete'),
            (113, '&#x0010;', 'F4'),
            (114, '&#x0005;', 'End'),
            (115, '&#x0001;', 'F2'),
            (116, '&#x000B;', 'Page Down'),
            (117, '&#x007F;', 'F1'),
            (118, '&#x0010;', None),
            (119, '&#x0004;', None),
            (120, '&#x0010;', None),
            (121, '&#x000C;', None),
            (122, '&#x0010;', None),
            (123, '&#x001C;', 'Left Arrow'),
            (124, '&#x001D;', 'Right Arrow'),
            (125, '&#x001F;', 'Down Arrow'),
            (126, '&#x001E;', 'Up Arrow'),
        ]
